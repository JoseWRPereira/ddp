---
layout: post
title: "P0101 - Pisca LED"
date: 2020-07-16 21:43:21 -0300
categories: ucPIC
badges:
 - type: danger
   tag: Microcontrolador
 - type: secondary
   tag: PIC
 - type: secondary
   tag: PIC16F887
---

# Pisca LED

Acionar um LED de forma intermitente com frequência de 1Hz.

<!--more-->

## Circuito


| Figura 1: Circuito de acionamento do LED |
|:------------------------------:|
| ![circuito]({{site.baseurlimg}}/_posts/tUcPIC/imgP0101/circuito.jpg{{site.rawimg}})|
| ![circuito]({{site.baseurlimg}}/_posts/tUcPIC/imgP0101/P0101-piscaLED.gif{{site.rawimg}})|
| Fonte: Próprio autor |


## Programa (*Firmware*)

``` C
/*
 * File:   main.c
 * Author: josewrpereira
 * 
 * Created on 21 de Setembro de 2019, 19:01
 * 
 * IDE:         MPLAB X IDE v3.15
 * Compiler:    XC8 v1.45
 * OS:          Deepin 15.11 X86_64
 * Kernel:      4.15.0-30deepin-generic
 * 
 * Objetivo: 
 *      Piscar o LED com intervalo de 500 ms
 * 
 * Pinos    |nº     |Conexão
 *  VDD     |11,32  | Alimentação (Vcc/+5V)
 *  VSS     |12,31  | Alimentação (GND/0V)
 *  RD0     |19     | LED
 */


#include <xc.h>                 // Inclui biblioteca padrão do compilador XC8 
                                // para microcontroladores Microchip.

#pragma config FOSC  = INTRC_NOCLKOUT   // Fonte de clock: oscilador interno
#pragma config WDTE  = OFF      // Desabilita WatchDog Timer 
#pragma config MCLRE = OFF      // Desab. Master Clear via pino
#pragma config LVP   = OFF      // Desab. gravação em baixa tensão

#define _XTAL_FREQ     4000000  // Freq. clock interno: 4MHz(padrão)

void main(void)                 // Função principal = main.
{                               // Início do bloco da função main.
    PORTDbits.RD0 = 0;          // Inicia RD0 com o valor 0.
    TRISDbits.TRISD0 = 0;       // Configura RD0 como Saída.
    
    while( 1 )                  // Laço de repetição infinito.
    {                           // Inicio do laço de repetição.
        PORTDbits.RD0 = 1;      // Liga RD0.
        __delay_ms(500);        // Espera 500 ms.
        PORTDbits.RD0 = 0;      // Desliga RD0.
        __delay_ms(500);        // Espera 500 ms.
    }                           // Fim do laço de repetição.
    return;                     // Caracteriza main como uma função sem retorno.
}                               // Fim do bloco da função main.

```


### Comentários

Os comentários são importantes para evidenciar ou explicar trechos de código que não são explícitos, de forma a garantir uma boa compreensão para quem venha a estudar o código.

Em linguagem C os comentátios podem ser feitos em `blocos` ou em `linha`:

* Bloco: tem como delimitador inicial `/*` e o final `*/`. Todo o conteúdo entre os delimitadores não são considerados pelo compilador, sendo úteis apenas para os programadores.
* Linha: a marcação `//` indica que todo o conteúdo à direita até o fim da linha é comentário, e da mesma forma não é considerado pelo compilador. 

Uma das informações que considero ser útil é mostrar quais pinos são usados e em qual aplicação, conforme segue:

```C
 /*
 * Pinos    |nº     |Conexão
 *  VDD     |11,32  | Alimentação (Vcc/+5V)
 *  VSS     |12,31  | Alimentação (GND/0V)
 *  RD0     |19     | LED
*/
```

### Inclusões de bibliotecas

O código `#include <xc.h>` inclui a biblioteca padrão do compilador XC8 para microcontroladores Microchip, de modo a oferecer funções básicas e as definições ou nomenclaturas dos registradores.

### Configurações de operação do uC

Algumas diretivas de compilação como `#pragma config` possibilitam o acesso exclusivo a alguns periféricos apenas durante a programação, entre eles temos as seguintes configurações básicas:

``` C
#pragma config FOSC  = INTRC_NOCLKOUT   // Fonte de clock: oscilador interno
#pragma config WDTE  = OFF              // Desabilita WatchDog Timer 
#pragma config MCLRE = OFF              // Desab. Master Clear via pino
#pragma config LVP   = OFF              // Desab. gravação em baixa tensão
```

Um destaque para a primeira linha em que o registrador `FOSC` é configurado para o oscilador interno. Por uma questão de simplificação de montagem inicial do circuito, optou-se por tal configuração por não necessitar de um cristal oscilador e seus capacitores conectados externamente.

### Definições

A definição `_XTAL_FREQ` deve assumir o valor do oscilador que estiver sendo utilizado na configuração, neste caso, o oscilador interno com o valor padrão é 4MHz. 

``` C
#define _XTAL_FREQ     4000000
```


### Programa principal

Todo programa em linguagem C deve possuir uma função principal, cujo nome é obrigatório `main`. 
As demais funções devem possuir nomes de acordo com a tarefa que executam, mas são de total responsabilidade do programador. 

Como no microcontrolador não há um sistema operacional para invocar a execução do programa, a função principal não necessita de um retorno, bem como não possui argumentos de entrada. 

```C
void main(void)
{                               // Início do bloco da função main.

    return;                     // Caracteriza main como uma função sem retorno.
}                               // Fim do bloco da função main.
```

### Parametrizar, habilitar e inicializar

A estrutura básica do programa para o microcontrolador(*firmware*) consiste em dois blocos de código, sendo o primeiro para a configuração e o segundo para o programa.


O bloco de configuração consiste em parametrizar, habilitar e/ou inicializar os periféricos e dados utilizados no programa.

O bloco para o programa consiste no código que normalmente é executado de forma repetida enquanto o sistema estiver em execução, ou seja, enquanto o microcontrolador estiver ligado.

O programa aqui apresentado utiliza o pino D0 do PORTD do microcontrolador por ser o PORT mais fácil de trabalhar. 

{% include alert.html 
type="primary" 
title="Como esse pino é parametrizado, habilitado e inicializado?" 
content=""
%}

{% include alert.html 
type="primary" 
title="Como configurar o pino como saída?"
content="" 
%}



#### Registradores

Todos os pinos possuem ao menos um circuito específico a eles conectados para realizar as funções as quais foram planejadas, entre elas, entrada digital, saída digital, contadores, comunicação, leitura de sinal analógico, etc.

Todos os periféricos, como circuitos, são configurados por sinais elétricos em portas específicas, e tais sinais podem ser acessados através do mapeamento desses sinais em um conjunto de registradores específico denominados **Registradores de Funções Especiais** (*SFR - Special Function Register*).

A Figura 2 mostra o mapa de registradores do PIC16F887 e pode ser acessada na página 25 do seu [*datasheet*](http://ww1.microchip.com/downloads/en/devicedoc/41291d.pdf).

|Figura 2: Mapa dos Registradores de Funções Especiais (*SFR*)|
|:----------------:|
| ![SFR     ]({{site.baseurlimg}}/_posts/tUcPIC/imgP0101/sfr-PIC16F886-7.png{{site.rawimg}})|
|Fonte: *Datasheet* do PIC16F887 |

Em destaque estão os registradores `PORTD` e `TRISD`, que são os responsáveis pela configuração e manipulação dos pinos conectados ao PORTD, inclusive o pino `D0` em que está conectado o ramo do circuito com o LED.

A Figura 3 mostra a representação do registrador PORTD utilizado para ler ou escrever um nível lógico no pino 19 ou RD0 do microcontrolador.

| Figura 3: Registrador PORTD |
|:----------:|
|![PORTDreg]({{ site.baseurlimg }}/_posts/tUcPIC/imgP0101/portdreg.png{{site.rawimg}})|
| Fonte: *Datasheet* do PIC16F887 |

O PORTD possui 8 bits acessíveis individualmente e independentes, como indicado pelo `R/W` acima do nome de cada bit. 
O `-x` significa que o valor de *reset* é desconecido, podendo ser 0 ou 1, mas nã é possível afirmar qual valor que estará cada bit ao ligar ou religar o microcontrolador.

Ao *setar* qualquer um dos bits do registrador com a instrução `PORTDbits.RDn = 1;` sendo `n` o número do bit que se está manipilando, o respectivo pino assume a tensão de alimentação do chip, +5V.

Ao *resetar* qualquer um dos bits do registrador com a instrução `PORTDbits.RDn = 0;` sendo `n` o número do bit que se está manipilando, o respectivo pino assume o valor de 0V.

Para realizar a leitura do pino, pode-se utilizar o seguinte comando: `var = PORTDbits.RDn;`, sendo `n` o número do bit acessado e `var` a variável que recebe o estado do pino acessado. 

Os dois estados lógicos são representados com os valores booleanos 0 e 1 e tais estados são assumidos quando a tensão no pino está dentro de um determinado intervalo de tensao:
*  2,0V < Nível Lógico Alto < 5.0V
*  0,0V < Nível Lógico Baixo < 0,8V

Note que para o intervalo entre 0,8 e 2,0, não há um estado bem definido, assim não é possível garantir para qual estado lógico será interpretada a leitura do pino.

A Figura 4 mostra a representação do registrador TRISD utilizado para configura o pino como entrada ou saída de dados no pino 19 ou RD0 do microcontrolador.

| Figura 4: Registrador TRISD |
|:----------:|
|![TRISDreg]({{ site.baseurlimg }}/_posts/tUcPIC/imgP0101/trisdreg.png{{site.rawimg}})|
| Fonte: *Datasheet* do PIC16F887 pág. 57 |

O TRISD possui 8 bits acessíveis individualmente e independentes, como indicado pelo `R/W` acima do nome de cada bit. 
O `-1` significa que o valor de *reset* é `1`, ou seja, todos os pinos são inicializados como entrada.

Um pino do PORTD pode ser configurado como entrada de dados com a seguinte instrução: `TRISDbits.TRISDn = 1;`, onde `n` é o número do bit que está se configurando. 

Para a configuração do pino como saída pode-se utilizar o seguinte comando: `TRISDbits.TRISDn = 0;`.


Tais registradores são um mapeamento do circuito da Figura 5, conforme segue.

| Figura 5: Diagrama dos pinos RD<4:0> |
|:----------:|
|![DiagramaRD0-4]({{ site.baseurlimg }}/_posts/tUcPIC/imgP0101/portD4-0_diagrama.png{{site.rawimg}})|
| Fonte: *Datasheet* do PIC16F887 pág. 58 |


Note que as ações de escrita e leitura de determinados registradores produz um sinal de controle no circuito do respectivo pino. O terminal `WR PORTD` é acionado quando a ação de escrita no PORTD ocorre. O mesmo ocorre para `WR TRISD`. Para a ação de leitura do registrador, é gerado um sinal de acionamento em `RD TRISD` ou `RD PORTD`, respectivamente. 

Os comandos de escrita acionam biestáveis (*flip-flops*) para armazenar a configuração ou o último dado escrito no pino. Para a leitura há apenas *buffers* de acesso ao dado do pino mediante os sinais de controle. 

As instruções de inicialização e configuração são apresentados abaixo e cada linha está ilustrada nas Figuras 6 e 7 em seguida: 

``` C
    PORTDbits.RD0 = 0;          // Inicia RD0 com o valor 0.
    TRISDbits.TRISD0 = 0;       // Configura RD0 como Saída.
```


| Figura 6: Diagrama dos pinos RD0-4 | Figura 7: Diagrama dos pinos RD0-4 |
|:----------:|:-----------:|
|![PORTD0-0]({{ site.baseurlimg }}/_posts/tUcPIC/imgP0101/portD0_0.png{{site.rawimg}})|![TRISD0-0]({{ site.baseurlimg }}/_posts/tUcPIC/imgP0101/trisd0_0.png{{site.rawimg}})|
| Fonte: *Datasheet* do PIC16F887 pág. 58 | Fonte: *Datasheet* do PIC16F887 pág. 58 |




### Ao infinito e além
A condição mais comum é que o programa fique sendo executado de forma repetida durante todo o período em que o microcontrolador estiver ligado, assim utiliza-se um laço de repetição com uma condição que é verdadeira sempre.

``` C
    while( 1 )                  // Laço de repetição infinito.
    {                           // Inicio do laço de repetição.
    }                           // Fim do laço de repetição.
```

Note que em linguagem C, para uma variável numérica, todo valor diferente de zero possui o estado lógico 1 (verdadeiro), enquanto que apenas o zero possui o estado lógico 0 (falso). 


Após a configuração do pino, sua inicialização, dentro do loop infinito a sequência de passos que atende o objetivo proposto.

1. Acionar RD0, ligando o LED;
2. Produzir um atraso de 500ms;
3. Desacionar RD0, desligando o LED;
4. Produzir um atraso de 500ms.

Codificando esses passos temos:

```c
        PORTDbits.RD0 = 1;      // Liga RD0.
        __delay_ms(500);        // Espera 500 ms.
        PORTDbits.RD0 = 0;      // Desliga RD0.
        __delay_ms(500);        // Espera 500 ms.
```

Os quatro passos completam o ciclo de acionamento do LED, e então este ciclo se repete em função do laço a qual ele está inserido.

Garantindo assim a correta execução e atendendo ao objetivo inicial de acionar o LED de forma intermitente com frequẽncia de 1Hz, ou seja, 500ms ligado e o mesmo tempo desligado. 


[Voltar]({{site.baseurl}}/docs/tecnology/ucPIC)