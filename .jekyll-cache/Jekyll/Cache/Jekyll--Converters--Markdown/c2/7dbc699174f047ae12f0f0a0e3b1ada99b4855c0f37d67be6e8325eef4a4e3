I"ıG<h1 id="pisca-led">Pisca LED</h1>

<p>Acionar um LED de forma intermitente com frequ√™ncia de 1Hz.</p>

<!--more-->

<h2 id="circuito">Circuito</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 1: Circuito de acionamento do LED</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/circuito.jpg?raw=true" alt="circuito" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: Pr√≥prio autor</td>
    </tr>
  </tbody>
</table>

<h2 id="programa-firmware">Programa (<em>Firmware</em>)</h2>

<pre><code class="language-C">/*
 * File:   main.c
 * Author: josewrpereira
 * 
 * Created on 21 de Setembro de 2019, 19:01
 * 
 * IDE:         MPLAB X IDE v3.15
 * Compiler:    XC8 v1.45
 * OS:          Deepin 15.11 X86_64
 * Kernel:      4.15.0-30deepin-generic
 * 
 * Objetivo: 
 *      Piscar o LED com intervalo de 500 ms
 * 
 * Pinos    |n¬∫     |Conex√£o
 *  VDD     |11,32  | Alimenta√ß√£o (Vcc/+5V)
 *  VSS     |12,31  | Alimenta√ß√£o (GND/0V)
 *  RD0     |19     | LED
 */


#include &lt;xc.h&gt;                 // Inclui biblioteca padr√£o do compilador XC8 
                                // para microcontroladores Microchip.

#pragma config FOSC  = INTRC_NOCLKOUT   // Fonte de clock: oscilador interno
#pragma config WDTE  = OFF      // Desabilita WatchDog Timer 
#pragma config MCLRE = OFF      // Desab. Master Clear via pino
#pragma config LVP   = OFF      // Desab. grava√ß√£o em baixa tens√£o

#define _XTAL_FREQ     4000000  // Freq. clock interno: 4MHz(padr√£o)

void main(void)                 // Fun√ß√£o principal = main.
{                               // In√≠cio do bloco da fun√ß√£o main.
    PORTDbits.RD0 = 0;          // Inicia RD0 com o valor 0.
    TRISDbits.TRISD0 = 0;       // Configura RD0 como Sa√≠da.
    
    while( 1 )                  // La√ßo de repeti√ß√£o infinito.
    {                           // Inicio do la√ßo de repeti√ß√£o.
        PORTDbits.RD0 = 1;      // Liga RD0.
        __delay_ms(500);        // Espera 500 ms.
        PORTDbits.RD0 = 0;      // Desliga RD0.
        __delay_ms(500);        // Espera 500 ms.
    }                           // Fim do la√ßo de repeti√ß√£o.
    return;                     // Caracteriza main como uma fun√ß√£o sem retorno.
}                               // Fim do bloco da fun√ß√£o main.

</code></pre>

<h3 id="coment√°rios">Coment√°rios</h3>

<p>Os coment√°rios s√£o importantes para evidenciar ou explicar trechos de c√≥digo que n√£o s√£o expl√≠citos, de forma a garantir uma boa compreens√£o para quem venha a estudar o c√≥digo.</p>

<p>Em linguagem C os coment√°tios podem ser feitos em <code class="language-plaintext highlighter-rouge">blocos</code> ou em <code class="language-plaintext highlighter-rouge">linha</code>:</p>

<ul>
  <li>Bloco: tem como delimitador inicial <code class="language-plaintext highlighter-rouge">/*</code> e o final <code class="language-plaintext highlighter-rouge">*/</code>. Todo o conte√∫do entre os delimitadores n√£o s√£o considerados pelo compilador, sendo √∫teis apenas para os programadores.</li>
  <li>Linha: a marca√ß√£o <code class="language-plaintext highlighter-rouge">//</code> indica que todo o conte√∫do √† direita at√© o fim da linha √© coment√°rio, e da mesma forma n√£o √© considerado pelo compilador.</li>
</ul>

<p>Uma das informa√ß√µes que considero ser √∫til √© mostrar quais pinos s√£o usados e em qual aplica√ß√£o, conforme segue:</p>

<pre><code class="language-C"> /*
 * Pinos    |n¬∫     |Conex√£o
 *  VDD     |11,32  | Alimenta√ß√£o (Vcc/+5V)
 *  VSS     |12,31  | Alimenta√ß√£o (GND/0V)
 *  RD0     |19     | LED
*/
</code></pre>

<h3 id="inclus√µes-de-bibliotecas">Inclus√µes de bibliotecas</h3>

<p>O c√≥digo <code class="language-plaintext highlighter-rouge">#include &lt;xc.h&gt;</code> inclui a biblioteca padr√£o do compilador XC8 para microcontroladores Microchip, de modo a oferecer fun√ß√µes b√°sicas e as defini√ß√µes ou nomenclaturas dos registradores.</p>

<h3 id="configura√ß√µes-de-opera√ß√£o-do-uc">Configura√ß√µes de opera√ß√£o do uC</h3>

<p>Algumas diretivas de compila√ß√£o como <code class="language-plaintext highlighter-rouge">#pragma config</code> possibilitam o acesso exclusivo a alguns perif√©ricos apenas durante a programa√ß√£o, entre eles temos as seguintes configura√ß√µes b√°sicas:</p>

<pre><code class="language-C">#pragma config FOSC  = INTRC_NOCLKOUT   // Fonte de clock: oscilador interno
#pragma config WDTE  = OFF              // Desabilita WatchDog Timer 
#pragma config MCLRE = OFF              // Desab. Master Clear via pino
#pragma config LVP   = OFF              // Desab. grava√ß√£o em baixa tens√£o
</code></pre>

<p>Um destaque para a primeira linha em que o registrador <code class="language-plaintext highlighter-rouge">FOSC</code> √© configurado para o oscilador interno. Por uma quest√£o de simplifica√ß√£o de montagem inicial do circuito, optou-se por tal configura√ß√£o por n√£o necessitar de um cristal oscilador e seus capacitores conectados externamente.</p>

<h3 id="defini√ß√µes">Defini√ß√µes</h3>

<p>A defini√ß√£o <code class="language-plaintext highlighter-rouge">_XTAL_FREQ</code> deve assumir o valor do oscilador que estiver sendo utilizado na configura√ß√£o, neste caso, o oscilador interno com o valor padr√£o √© 4MHz.</p>

<pre><code class="language-C">#define _XTAL_FREQ     4000000
</code></pre>

<h3 id="programa-principal">Programa principal</h3>

<p>Todo programa em linguagem C deve possuir uma fun√ß√£o principal, cujo nome √© obrigat√≥rio <code class="language-plaintext highlighter-rouge">main</code>. 
As demais fun√ß√µes devem possuir nomes de acordo com a tarefa que executam, mas s√£o de total responsabilidade do programador.</p>

<p>Como no microcontrolador n√£o h√° um sistema operacional para invocar a execu√ß√£o do programa, a fun√ß√£o principal n√£o necessita de um retorno, bem como n√£o possui argumentos de entrada.</p>

<pre><code class="language-C">void main(void)
{                               // In√≠cio do bloco da fun√ß√£o main.

    return;                     // Caracteriza main como uma fun√ß√£o sem retorno.
}                               // Fim do bloco da fun√ß√£o main.
</code></pre>

<h3 id="parametrizar-habilitar-e-inicializar">Parametrizar, habilitar e inicializar</h3>

<p>A estrutura b√°sica do programa para o microcontrolador(<em>firmware</em>) consiste em dois blocos de c√≥digo, sendo o primeiro para a configura√ß√£o e o segundo para o programa.</p>

<p>O bloco de configura√ß√£o consiste em parametrizar, habilitar e/ou inicializar os perif√©ricos e dados utilizados no programa.</p>

<p>O bloco para o programa consiste no c√≥digo que normalmente √© executado de forma repetida enquanto o sistema estiver em execu√ß√£o, ou seja, enquanto o microcontrolador estiver ligado.</p>

<p>O programa aqui apresentado utiliza o pino D0 do PORTD do microcontrolador por ser o PORT mais f√°cil de trabalhar.</p>

<blockquote>
  <blockquote>
    <p>Como esse pino √© parametrizado, habilitado e inicializado?</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>Como configurar o pino como sa√≠da?</p>
  </blockquote>
</blockquote>

<h4 id="registradores">Registradores</h4>

<p>Todos os pinos possuem ao menos um circuito espec√≠fico a eles conectados para realizar as fun√ß√µes as quais foram planejadas, entre elas, entrada digital, sa√≠da digital, contadores, comunica√ß√£o, leitura de sinal anal√≥gico, etc.</p>

<p>Todos os perif√©ricos, como circuitos, s√£o configurados por sinais el√©tricos em portas espec√≠ficas, e tais sinais podem ser acessados atrav√©s do mapeamento desses sinais em um conjunto de registradores espec√≠fico denominados <strong>Registradores de Fun√ß√µes Especiais</strong> (<em>SFR - Special Function Register</em>).</p>

<p>A Figura 2 mostra o mapa de registradores do PIC16F887 e pode ser acessada na p√°gina 25 do seu <a href="http://ww1.microchip.com/downloads/en/devicedoc/41291d.pdf"><em>datasheet</em></a>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 2: Mapa dos Registradores de Fun√ß√µes Especiais (<em>SFR</em>)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/sfr-PIC16F886-7.png?raw=true" alt="SFR     " /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887</td>
    </tr>
  </tbody>
</table>

<p>Em destaque est√£o os registradores <code class="language-plaintext highlighter-rouge">PORTD</code> e <code class="language-plaintext highlighter-rouge">TRISD</code>, que s√£o os respons√°veis pela configura√ß√£o e manipula√ß√£o dos pinos conectados ao PORTD, inclusive o pino <code class="language-plaintext highlighter-rouge">D0</code> em que est√° conectado o ramo do circuito com o LED.</p>

<p>A Figura 3 mostra a representa√ß√£o do registrador PORTD utilizado para ler ou escrever um n√≠vel l√≥gico no pino 19 ou RD0 do microcontrolador.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 3: Registrador PORTD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/portdreg.png?raw=true" alt="PORTDreg" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887</td>
    </tr>
  </tbody>
</table>

<p>O PORTD possui 8 bits acess√≠veis individualmente e independentes, como indicado pelo <code class="language-plaintext highlighter-rouge">R/W</code> acima do nome de cada bit. 
O <code class="language-plaintext highlighter-rouge">-x</code> significa que o valor de <em>reset</em> √© desconecido, podendo ser 0 ou 1, mas n√£ √© poss√≠vel afirmar qual valor que estar√° cada bit ao ligar ou religar o microcontrolador.</p>

<p>Ao <em>setar</em> qualquer um dos bits do registrador com a instru√ß√£o <code class="language-plaintext highlighter-rouge">PORTDbits.RDn = 1;</code> sendo <code class="language-plaintext highlighter-rouge">n</code> o n√∫mero do bit que se est√° manipilando, o respectivo pino assume a tens√£o de alimenta√ß√£o do chip, +5V.</p>

<p>Ao <em>resetar</em> qualquer um dos bits do registrador com a instru√ß√£o <code class="language-plaintext highlighter-rouge">PORTDbits.RDn = 0;</code> sendo <code class="language-plaintext highlighter-rouge">n</code> o n√∫mero do bit que se est√° manipilando, o respectivo pino assume o valor de 0V.</p>

<p>Para realizar a leitura do pino, pode-se utilizar o seguinte comando: <code class="language-plaintext highlighter-rouge">var = PORTDbits.RDn;</code>, sendo <code class="language-plaintext highlighter-rouge">n</code> o n√∫mero do bit acessado e <code class="language-plaintext highlighter-rouge">var</code> a vari√°vel que recebe o estado do pino acessado.</p>

<p>Os dois estados l√≥gicos s√£o representados com os valores booleanos 0 e 1 e tais estados s√£o assumidos quando a tens√£o no pino est√° dentro de um determinado intervalo de tensao:</p>
<ul>
  <li>2,0V &lt; N√≠vel L√≥gico Alto &lt; 5.0V</li>
  <li>0,0V &lt; N√≠vel L√≥gico Baixo &lt; 0,8V</li>
</ul>

<p>Note que para o intervalo entre 0,8 e 2,0, n√£o h√° um estado bem definido, assim n√£o √© poss√≠vel garantir para qual estado l√≥gico ser√° interpretada a leitura do pino.</p>

<p>A Figura 4 mostra a representa√ß√£o do registrador TRISD utilizado para configura o pino como entrada ou sa√≠da de dados no pino 19 ou RD0 do microcontrolador.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 4: Registrador TRISD</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/trisdreg.png?raw=true" alt="TRISDreg" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887 p√°g. 57</td>
    </tr>
  </tbody>
</table>

<p>O TRISD possui 8 bits acess√≠veis individualmente e independentes, como indicado pelo <code class="language-plaintext highlighter-rouge">R/W</code> acima do nome de cada bit. 
O <code class="language-plaintext highlighter-rouge">-1</code> significa que o valor de <em>reset</em> √© <code class="language-plaintext highlighter-rouge">1</code>, ou seja, todos os pinos s√£o inicializados como entrada.</p>

<p>Um pino do PORTD pode ser configurado como entrada de dados com a seguinte instru√ß√£o: <code class="language-plaintext highlighter-rouge">TRISDbits.TRISDn = 1;</code>, onde <code class="language-plaintext highlighter-rouge">n</code> √© o n√∫mero do bit que est√° se configurando.</p>

<p>Para a configura√ß√£o do pino como sa√≠da pode-se utilizar o seguinte comando: <code class="language-plaintext highlighter-rouge">TRISDbits.TRISDn = 0;</code>.</p>

<p>Tais registradores s√£o um mapeamento do circuito da Figura 5, conforme segue.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 5: Diagrama dos pinos RD&lt;4:0&gt;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/portD4-0_diagrama.png?raw=true" alt="DiagramaRD0-4" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887 p√°g. 58</td>
    </tr>
  </tbody>
</table>

<p>Note que as a√ß√µes de escrita e leitura de determinados registradores produz um sinal de controle no circuito do respectivo pino. O terminal <code class="language-plaintext highlighter-rouge">WR PORTD</code> √© acionado quando a a√ß√£o de escrita no PORTD ocorre. O mesmo ocorre para <code class="language-plaintext highlighter-rouge">WR TRISD</code>. Para a a√ß√£o de leitura do registrador, √© gerado um sinal de acionamento em <code class="language-plaintext highlighter-rouge">RD TRISD</code> ou <code class="language-plaintext highlighter-rouge">RD PORTD</code>, respectivamente.</p>

<p>Os comandos de escrita acionam biest√°veis (<em>flip-flops</em>) para armazenar a configura√ß√£o ou o √∫ltimo dado escrito no pino. Para a leitura h√° apenas <em>buffers</em> de acesso ao dado do pino mediante os sinais de controle.</p>

<p>As instru√ß√µes de inicializa√ß√£o e configura√ß√£o s√£o apresentados abaixo e cada linha est√° ilustrada nas Figuras 6 e 7 em seguida:</p>

<pre><code class="language-C">    PORTDbits.RD0 = 0;          // Inicia RD0 com o valor 0.
    TRISDbits.TRISD0 = 0;       // Configura RD0 como Sa√≠da.
</code></pre>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Figura 6: Diagrama dos pinos RD0-4</th>
      <th style="text-align: center">Figura 7: Diagrama dos pinos RD0-4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/portD0_0.png?raw=true" alt="PORTD0-0" /></td>
      <td style="text-align: center"><img src="https://github.com/JoseWRPereira/ddp/blob/master//_posts/tUcPIC/imgP0101/trisd0_0.png?raw=true" alt="TRISD0-0" /></td>
    </tr>
    <tr>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887 p√°g. 58</td>
      <td style="text-align: center">Fonte: <em>Datasheet</em> do PIC16F887 p√°g. 58</td>
    </tr>
  </tbody>
</table>

<h3 id="ao-infinito-e-al√©m">Ao infinito e al√©m</h3>
<p>A condi√ß√£o mais comum √© que o programa fique sendo executado de forma repetida durante todo o per√≠odo em que o microcontrolador estiver ligado, assim utiliza-se um la√ßo de repeti√ß√£o com uma condi√ß√£o que √© verdadeira sempre.</p>

<pre><code class="language-C">    while( 1 )                  // La√ßo de repeti√ß√£o infinito.
    {                           // Inicio do la√ßo de repeti√ß√£o.
    }                           // Fim do la√ßo de repeti√ß√£o.
</code></pre>

<p>Note que em linguagem C, para uma vari√°vel num√©rica, todo valor diferente de zero possui o estado l√≥gico 1 (verdadeiro), enquanto que apenas o zero possui o estado l√≥gico 0 (falso).</p>

<p>Ap√≥s a configura√ß√£o do pino, sua inicializa√ß√£o, dentro do loop infinito a sequ√™ncia de passos que atende o objetivo proposto.</p>

<ol>
  <li>Acionar RD0, ligando o LED;</li>
  <li>Produzir um atraso de 500ms;</li>
  <li>Desacionar RD0, desligando o LED;</li>
  <li>Produzir um atraso de 500ms.</li>
</ol>

<p>Codificando esses passos temos:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">PORTDbits</span><span class="p">.</span><span class="n">RD0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// Liga RD0.</span>
        <span class="n">__delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>        <span class="c1">// Espera 500 ms.</span>
        <span class="n">PORTDbits</span><span class="p">.</span><span class="n">RD0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Desliga RD0.</span>
        <span class="n">__delay_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>        <span class="c1">// Espera 500 ms.</span>
</code></pre></div></div>

<p>Os quatro passos completam o ciclo de acionamento do LED, e ent√£o este ciclo se repete em fun√ß√£o do la√ßo a qual ele est√° inserido.</p>

<p>Garantindo assim a correta execu√ß√£o e atendendo ao objetivo inicial de acionar o LED de forma intermitente com frequ·∫Ωncia de 1Hz, ou seja, 500ms ligado e o mesmo tempo desligado.</p>

<div class="alert alert-warning" role="alert">
<h4 class="alert-heading">warning</h4>
This is a warning
</div>

<div class="alert alert-danger" role="alert">
<h4 class="alert-heading">danger</h4>
This alerts danger!
</div>

<div class="alert alert-success" role="alert">
<h4 class="alert-heading">success</h4>
This alerts success
</div>

<div class="alert alert-info" role="alert">
<h4 class="alert-heading">info</h4>
This is useful information.
</div>

<div class="alert alert-primary" role="alert">
<h4 class="alert-heading">primary</h4>
This is a primary alert
</div>

<div class="alert alert-secondary" role="alert">
<h4 class="alert-heading">secondary</h4>
This is a secondary alert
</div>
:ET